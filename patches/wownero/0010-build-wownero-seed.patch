From 918eaf1bdabb003ba1d2857ecd564c76cf440c19 Mon Sep 17 00:00:00 2001
From: Czarek Nakamoto <cyjan@mrcyjanek.net>
Date: Thu, 25 Apr 2024 10:06:04 +0200
Subject: [PATCH] build wownero-seed

---
 contrib/depends/packages/wownero_seed.mk      |  27 ++
 .../0001-fix-duplicate-symbol-error.patch     | 273 ++++++++++++++++++
 2 files changed, 300 insertions(+)
 create mode 100644 contrib/depends/packages/wownero_seed.mk
 create mode 100644 contrib/depends/patches/wownero_seed/0001-fix-duplicate-symbol-error.patch

diff --git a/contrib/depends/packages/wownero_seed.mk b/contrib/depends/packages/wownero_seed.mk
new file mode 100644
index 000000000..2747b8c65
--- /dev/null
+++ b/contrib/depends/packages/wownero_seed.mk
@@ -0,0 +1,27 @@
+package=wownero_seed
+$(package)_version=0.3.0
+$(package)_download_path=https://github.com/MrCyjaneK/wownero-seed/archive/
+$(package)_download_file=d3f68be347facfeebbd8f68fd74982c705cb917b.tar.gz
+$(package)_file_name=$(package)-$($(package)_version).tar.gz
+$(package)_sha256_hash=3b59ccde08e0fee204680240af4b270a18a677aa0e6036a3504570193d232406
+# $(package)_patches=
+
+define $(package)_preprocess_cmds
+    patch -p1 < $($(package)_patch_dir)/0001-fix-duplicate-symbol-error.patch
+endef
+
+define $(package)_config_cmds
+    CC="$($(package)_cc)" cmake -DCMAKE_INSTALL_PREFIX="$(host_prefix)" .
+endef
+
+define $(package)_set_vars
+  $(package)_build_opts=CC="$($(package)_cc)"
+endef
+
+define $(package)_build_cmds
+    CC="$($(package)_cc)" $(MAKE)
+endef
+
+define $(package)_stage_cmds
+    $(MAKE) DESTDIR=$($(package)_staging_dir) install
+endef
diff --git a/contrib/depends/patches/wownero_seed/0001-fix-duplicate-symbol-error.patch b/contrib/depends/patches/wownero_seed/0001-fix-duplicate-symbol-error.patch
new file mode 100644
index 000000000..810a65f38
--- /dev/null
+++ b/contrib/depends/patches/wownero_seed/0001-fix-duplicate-symbol-error.patch
@@ -0,0 +1,273 @@
+From b95535acbb18895a9d9894e64815cfca460ab95c Mon Sep 17 00:00:00 2001
+From: Czarek Nakamoto <cyjan@mrcyjanek.net>
+Date: Thu, 25 Apr 2024 09:37:37 +0200
+Subject: [PATCH] fix duplicate symbol error
+
+---
+ src/argon2/blake2/blake2.h  | 12 +++++-----
+ src/argon2/blake2/blake2b.c | 46 ++++++++++++++++++-------------------
+ src/argon2/core.c           | 32 +++++++++++++-------------
+ 3 files changed, 45 insertions(+), 45 deletions(-)
+
+diff --git a/src/argon2/blake2/blake2.h b/src/argon2/blake2/blake2.h
+index 9f97e1c..25b445d 100644
+--- a/src/argon2/blake2/blake2.h
++++ b/src/argon2/blake2/blake2.h
+@@ -67,15 +67,15 @@ enum {
+ };
+ 
+ /* Streaming API */
+-ARGON2_LOCAL int blake2b_init(blake2b_state *S, size_t outlen);
+-ARGON2_LOCAL int blake2b_init_key(blake2b_state *S, size_t outlen, const void *key,
++ARGON2_LOCAL int blake2b_init_wowseed(blake2b_state *S, size_t outlen);
++ARGON2_LOCAL int blake2b_init_key_wowseed(blake2b_state *S, size_t outlen, const void *key,
+                      size_t keylen);
+-ARGON2_LOCAL int blake2b_init_param(blake2b_state *S, const blake2b_param *P);
+-ARGON2_LOCAL int blake2b_update(blake2b_state *S, const void *in, size_t inlen);
+-ARGON2_LOCAL int blake2b_final(blake2b_state *S, void *out, size_t outlen);
++ARGON2_LOCAL int blake2b_init_param_wowseed(blake2b_state *S, const blake2b_param *P);
++ARGON2_LOCAL int blake2b_update_wowseed(blake2b_state *S, const void *in, size_t inlen);
++ARGON2_LOCAL int blake2b_final_wowseed(blake2b_state *S, void *out, size_t outlen);
+ 
+ /* Simple API */
+-ARGON2_LOCAL int blake2b(void *out, size_t outlen, const void *in, size_t inlen,
++ARGON2_LOCAL int blake2b_wowseed(void *out, size_t outlen, const void *in, size_t inlen,
+                          const void *key, size_t keylen);
+ 
+ /* Argon2 Team - Begin Code */
+diff --git a/src/argon2/blake2/blake2b.c b/src/argon2/blake2/blake2b.c
+index ca05df5..8138b86 100644
+--- a/src/argon2/blake2/blake2b.c
++++ b/src/argon2/blake2/blake2b.c
+@@ -70,7 +70,7 @@ static BLAKE2_INLINE void blake2b_init0(blake2b_state *S) {
+     memcpy(S->h, blake2b_IV, sizeof(S->h));
+ }
+ 
+-int blake2b_init_param(blake2b_state *S, const blake2b_param *P) {
++int blake2b_init_param_wowseed(blake2b_state *S, const blake2b_param *P) {
+     const unsigned char *p = (const unsigned char *)P;
+     unsigned int i;
+ 
+@@ -88,7 +88,7 @@ int blake2b_init_param(blake2b_state *S, const blake2b_param *P) {
+ }
+ 
+ /* Sequential blake2b initialization */
+-int blake2b_init(blake2b_state *S, size_t outlen) {
++int blake2b_init_wowseed(blake2b_state *S, size_t outlen) {
+     blake2b_param P;
+ 
+     if (S == NULL) {
+@@ -113,10 +113,10 @@ int blake2b_init(blake2b_state *S, size_t outlen) {
+     memset(P.salt, 0, sizeof(P.salt));
+     memset(P.personal, 0, sizeof(P.personal));
+ 
+-    return blake2b_init_param(S, &P);
++    return blake2b_init_param_wowseed(S, &P);
+ }
+ 
+-int blake2b_init_key(blake2b_state *S, size_t outlen, const void *key,
++int blake2b_init_key_wowseed(blake2b_state *S, size_t outlen, const void *key,
+                      size_t keylen) {
+     blake2b_param P;
+ 
+@@ -147,7 +147,7 @@ int blake2b_init_key(blake2b_state *S, size_t outlen, const void *key,
+     memset(P.salt, 0, sizeof(P.salt));
+     memset(P.personal, 0, sizeof(P.personal));
+ 
+-    if (blake2b_init_param(S, &P) < 0) {
++    if (blake2b_init_param_wowseed(S, &P) < 0) {
+         blake2b_invalidate_state(S);
+         return -1;
+     }
+@@ -156,7 +156,7 @@ int blake2b_init_key(blake2b_state *S, size_t outlen, const void *key,
+         uint8_t block[BLAKE2B_BLOCKBYTES];
+         memset(block, 0, BLAKE2B_BLOCKBYTES);
+         memcpy(block, key, keylen);
+-        blake2b_update(S, block, BLAKE2B_BLOCKBYTES);
++        blake2b_update_wowseed(S, block, BLAKE2B_BLOCKBYTES);
+         /* Burn the key from stack */
+         clear_internal_memory(block, BLAKE2B_BLOCKBYTES);
+     }
+@@ -221,7 +221,7 @@ static void blake2b_compress(blake2b_state *S, const uint8_t *block) {
+ #undef ROUND
+ }
+ 
+-int blake2b_update(blake2b_state *S, const void *in, size_t inlen) {
++int blake2b_update_wowseed(blake2b_state *S, const void *in, size_t inlen) {
+     const uint8_t *pin = (const uint8_t *)in;
+ 
+     if (inlen == 0) {
+@@ -261,7 +261,7 @@ int blake2b_update(blake2b_state *S, const void *in, size_t inlen) {
+     return 0;
+ }
+ 
+-int blake2b_final(blake2b_state *S, void *out, size_t outlen) {
++int blake2b_final_wowseed(blake2b_state *S, void *out, size_t outlen) {
+     uint8_t buffer[BLAKE2B_OUTBYTES] = {0};
+     unsigned int i;
+ 
+@@ -291,7 +291,7 @@ int blake2b_final(blake2b_state *S, void *out, size_t outlen) {
+     return 0;
+ }
+ 
+-int blake2b(void *out, size_t outlen, const void *in, size_t inlen,
++int blake2b_wowseed(void *out, size_t outlen, const void *in, size_t inlen,
+             const void *key, size_t keylen) {
+     blake2b_state S;
+     int ret = -1;
+@@ -310,19 +310,19 @@ int blake2b(void *out, size_t outlen, const void *in, size_t inlen,
+     }
+ 
+     if (keylen > 0) {
+-        if (blake2b_init_key(&S, outlen, key, keylen) < 0) {
++        if (blake2b_init_key_wowseed(&S, outlen, key, keylen) < 0) {
+             goto fail;
+         }
+     } else {
+-        if (blake2b_init(&S, outlen) < 0) {
++        if (blake2b_init_wowseed(&S, outlen) < 0) {
+             goto fail;
+         }
+     }
+ 
+-    if (blake2b_update(&S, in, inlen) < 0) {
++    if (blake2b_update_wowseed(&S, in, inlen) < 0) {
+         goto fail;
+     }
+-    ret = blake2b_final(&S, out, outlen);
++    ret = blake2b_final_wowseed(&S, out, outlen);
+ 
+ fail:
+     clear_internal_memory(&S, sizeof(S));
+@@ -352,25 +352,25 @@ int blake2b_long(void *pout, size_t outlen, const void *in, size_t inlen) {
+     } while ((void)0, 0)
+ 
+     if (outlen <= BLAKE2B_OUTBYTES) {
+-        TRY(blake2b_init(&blake_state, outlen));
+-        TRY(blake2b_update(&blake_state, outlen_bytes, sizeof(outlen_bytes)));
+-        TRY(blake2b_update(&blake_state, in, inlen));
+-        TRY(blake2b_final(&blake_state, out, outlen));
++        TRY(blake2b_init_wowseed(&blake_state, outlen));
++        TRY(blake2b_update_wowseed(&blake_state, outlen_bytes, sizeof(outlen_bytes)));
++        TRY(blake2b_update_wowseed(&blake_state, in, inlen));
++        TRY(blake2b_final_wowseed(&blake_state, out, outlen));
+     } else {
+         uint32_t toproduce;
+         uint8_t out_buffer[BLAKE2B_OUTBYTES];
+         uint8_t in_buffer[BLAKE2B_OUTBYTES];
+-        TRY(blake2b_init(&blake_state, BLAKE2B_OUTBYTES));
+-        TRY(blake2b_update(&blake_state, outlen_bytes, sizeof(outlen_bytes)));
+-        TRY(blake2b_update(&blake_state, in, inlen));
+-        TRY(blake2b_final(&blake_state, out_buffer, BLAKE2B_OUTBYTES));
++        TRY(blake2b_init_wowseed(&blake_state, BLAKE2B_OUTBYTES));
++        TRY(blake2b_update_wowseed(&blake_state, outlen_bytes, sizeof(outlen_bytes)));
++        TRY(blake2b_update_wowseed(&blake_state, in, inlen));
++        TRY(blake2b_final_wowseed(&blake_state, out_buffer, BLAKE2B_OUTBYTES));
+         memcpy(out, out_buffer, BLAKE2B_OUTBYTES / 2);
+         out += BLAKE2B_OUTBYTES / 2;
+         toproduce = (uint32_t)outlen - BLAKE2B_OUTBYTES / 2;
+ 
+         while (toproduce > BLAKE2B_OUTBYTES) {
+             memcpy(in_buffer, out_buffer, BLAKE2B_OUTBYTES);
+-            TRY(blake2b(out_buffer, BLAKE2B_OUTBYTES, in_buffer,
++            TRY(blake2b_wowseed(out_buffer, BLAKE2B_OUTBYTES, in_buffer,
+                         BLAKE2B_OUTBYTES, NULL, 0));
+             memcpy(out, out_buffer, BLAKE2B_OUTBYTES / 2);
+             out += BLAKE2B_OUTBYTES / 2;
+@@ -378,7 +378,7 @@ int blake2b_long(void *pout, size_t outlen, const void *in, size_t inlen) {
+         }
+ 
+         memcpy(in_buffer, out_buffer, BLAKE2B_OUTBYTES);
+-        TRY(blake2b(out_buffer, toproduce, in_buffer, BLAKE2B_OUTBYTES, NULL,
++        TRY(blake2b_wowseed(out_buffer, toproduce, in_buffer, BLAKE2B_OUTBYTES, NULL,
+                     0));
+         memcpy(out, out_buffer, toproduce);
+     }
+diff --git a/src/argon2/core.c b/src/argon2/core.c
+index 5eafe08..f59db34 100644
+--- a/src/argon2/core.c
++++ b/src/argon2/core.c
+@@ -439,31 +439,31 @@ void initial_hash(uint8_t *blockhash, argon2_context *context,
+         return;
+     }
+ 
+-    blake2b_init(&BlakeHash, ARGON2_PREHASH_DIGEST_LENGTH);
++    blake2b_init_wowseed(&BlakeHash, ARGON2_PREHASH_DIGEST_LENGTH);
+ 
+     store32(&value, context->lanes);
+-    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));
++    blake2b_update_wowseed(&BlakeHash, (const uint8_t *)&value, sizeof(value));
+ 
+     store32(&value, context->outlen);
+-    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));
++    blake2b_update_wowseed(&BlakeHash, (const uint8_t *)&value, sizeof(value));
+ 
+     store32(&value, context->m_cost);
+-    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));
++    blake2b_update_wowseed(&BlakeHash, (const uint8_t *)&value, sizeof(value));
+ 
+     store32(&value, context->t_cost);
+-    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));
++    blake2b_update_wowseed(&BlakeHash, (const uint8_t *)&value, sizeof(value));
+ 
+     store32(&value, context->version);
+-    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));
++    blake2b_update_wowseed(&BlakeHash, (const uint8_t *)&value, sizeof(value));
+ 
+     store32(&value, (uint32_t)type);
+-    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));
++    blake2b_update_wowseed(&BlakeHash, (const uint8_t *)&value, sizeof(value));
+ 
+     store32(&value, context->pwdlen);
+-    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));
++    blake2b_update_wowseed(&BlakeHash, (const uint8_t *)&value, sizeof(value));
+ 
+     if (context->pwd != NULL) {
+-        blake2b_update(&BlakeHash, (const uint8_t *)context->pwd,
++        blake2b_update_wowseed(&BlakeHash, (const uint8_t *)context->pwd,
+                        context->pwdlen);
+ 
+         if (context->flags & ARGON2_FLAG_CLEAR_PASSWORD) {
+@@ -473,18 +473,18 @@ void initial_hash(uint8_t *blockhash, argon2_context *context,
+     }
+ 
+     store32(&value, context->saltlen);
+-    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));
++    blake2b_update_wowseed(&BlakeHash, (const uint8_t *)&value, sizeof(value));
+ 
+     if (context->salt != NULL) {
+-        blake2b_update(&BlakeHash, (const uint8_t *)context->salt,
++        blake2b_update_wowseed(&BlakeHash, (const uint8_t *)context->salt,
+                        context->saltlen);
+     }
+ 
+     store32(&value, context->secretlen);
+-    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));
++    blake2b_update_wowseed(&BlakeHash, (const uint8_t *)&value, sizeof(value));
+ 
+     if (context->secret != NULL) {
+-        blake2b_update(&BlakeHash, (const uint8_t *)context->secret,
++        blake2b_update_wowseed(&BlakeHash, (const uint8_t *)context->secret,
+                        context->secretlen);
+ 
+         if (context->flags & ARGON2_FLAG_CLEAR_SECRET) {
+@@ -494,14 +494,14 @@ void initial_hash(uint8_t *blockhash, argon2_context *context,
+     }
+ 
+     store32(&value, context->adlen);
+-    blake2b_update(&BlakeHash, (const uint8_t *)&value, sizeof(value));
++    blake2b_update_wowseed(&BlakeHash, (const uint8_t *)&value, sizeof(value));
+ 
+     if (context->ad != NULL) {
+-        blake2b_update(&BlakeHash, (const uint8_t *)context->ad,
++        blake2b_update_wowseed(&BlakeHash, (const uint8_t *)context->ad,
+                        context->adlen);
+     }
+ 
+-    blake2b_final(&BlakeHash, blockhash, ARGON2_PREHASH_DIGEST_LENGTH);
++    blake2b_final_wowseed(&BlakeHash, blockhash, ARGON2_PREHASH_DIGEST_LENGTH);
+ }
+ 
+ int initialize(argon2_instance_t *instance, argon2_context *context) {
+-- 
+2.44.0
-- 
2.44.0

